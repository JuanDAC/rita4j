/*
 * This Java source file was generated by the Gradle "init" task.
 */
package rita.test;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import org.junit.Test;
public class LexiconTests {

	@Test
	public void testHasWord() {
		assertTrue(RiTa.hasWord("random"));
	}

	@Test
	public void randomWord() {
		String result;

//    result = RiTa.randomWord();
//		assertTrue(result.length > 0);

		Map<String, Object> hm = new HashMap<String, Object>();
		hm.put("pos", "nn");
		result = RiTa.randomWord(hm);
		assertTrue(result.length() > 0);

		hm.clear();
		hm.put("pos", "nns");
		result = RiTa.randomWord(hm);
		assertTrue(result.length() > 0);

		hm.clear();
		hm.put("pos", "n");
		result = RiTa.randomWord(hm);
		assertTrue(result.length() > 0);

		hm.clear();
		hm.put("pos", "v");
		result = RiTa.randomWord(hm);
		assertTrue(result.length() > 0);

		hm.clear();
		hm.put("numSyllables", 3);
		result = RiTa.randomWord(hm);
		assertTrue(result.length() > 0);

		hm.clear();
		hm.put("numSyllables", 5);
		result = RiTa.randomWord(hm);
		assertTrue(result.length() > 0);

	}

	@Test
	public void testAugmentedLexicon() {
		Lexicon lexicon = RiTa._lexicon();
		// toAdd = {
		// "deg": ["d-eh1-g", "nn"],
		// "wadly": ["w-ae1-d l-iy", "rb"],
		// }
		// lexicon.data()
		// TODO:

		assertTrue(RiTa.hasWord("run"));
		assertTrue(RiTa.hasWord("walk"));
		assertTrue(RiTa.hasWord("deg"));
		assertTrue(RiTa.hasWord("wadly"));
		assertTrue(RiTa.isAlliteration("wadly", "welcome"));
	}

	@Test
	public void testCustomLexicon() {
		Lexicon lexicon = RiTa._lexicon();
		// TODO:
		// lex.data = {
		// "dog": ["d-ao1-g", "nn"],
		// "cat": ["k-ae1-t", "nn"],
		// "happily": ["hh-ae1 p-ah l-iy", "rb"],
		// "walk": ["w-ao1-k", "vb vbp nn"],
		// "welcome": ["w-eh1-l k-ah-m", "jj nn vb vbp"],
		// "sadly": ["s-ae1-d l-iy", "rb"],
		// }

		assertTrue(!RiTa.hasWord("run"));
		assertTrue(RiTa.hasWord("walk"));
		assertTrue(RiTa.isAlliteration("walk", "welcome"));
		// lex.data = orig;
	}

	@Test
	public void testRandomWordNNS() {
		Map<String, Object> hm = new HashMap<String, Object>();
		hm.put("pos", "nns");

		for (int i = 0; i < 20; i++) {
      String result = RiTa.randomWord(hm);
      if (!RiTa.Pluralizer.isPlural(result)) {
        // For now, just warn here as there are too many edge cases (see #521)
        System.err.println("Pluralize/Singularize problem: randomWord(nns) was "" + result + "" (" +
          "isPlural=" + RiTa.inflector.isPlural(result) + "), singularized is "" + RiTa.singularize(result) + """);
      }
      // TODO: occasional problem here, examples: beaux

      //No vbg, No -ness, -ism
      String pos = RiTa._lexicon()._posData(result); //private
			assertTrue(pos.length() > 0);
			assertTrue(pos.indexOf("vbg") < 0);
			assertTrue(!result.endsWith("ness"));
			assertTrue(!result.endsWith("isms"));
    }

	}

	@Test
	public void testRandomWordPos() {
		String[] pos = {"nn", "jj", "jjr", "wp"};
		Map<String, Object> hm = new HashMap<String, Object>();

		for (int j = 0; j < pos.length; j++) {
      for (int i = 0; i < 5; i++) {
				hm.clear()
				hm.put("pos", pos[j]);
        String result = RiTa.randomWord(hm);
        String best = RiTa._lexicon()._bestPos(result);// private
        //System.out.println(result+": "+pos[j]+" ?= "+best);
        assertEquals(pos[j], best);
      }
    }

	}

	@Test
	public void testRandomWordSyls() {
		int i = 0;
		String result = "";
		String syllables = "";
		int num = 0;
		Map<String, Object> hm = new HashMap<String, Object>();

		hm.put("numSyllables", 3);
    for (i = 0; i < 10; i++) {
      result = RiTa.randomWord(hm);
      syllables = RiTa.syllables(result);
      num = syllables.split(RiTa.SYLLABLE_BOUNDARY).length;
			assertTrue(result.length() > 0);
			assertTrue(num == 3); // "3 syllables: "
    }

		hm.clear()
		hm.put("numSyllables", 5);
    for (i = 0; i < 10; i++) {
      result = RiTa.randomWord(hm);
      syllables = RiTa.syllables(result);
      num = syllables.split(RiTa.SYLLABLE_BOUNDARY).length;
			assertTrue(result.length() > 0);
			assertTrue(num == 5); // "5 syllables: "
    }

	}

	@Test
	public void testSearchWithoutOpts() {
		// TODO:
		assertTrue(RiTa.search().length > 20000);
	}

	@Test
	public void testSearchWithLetters() {
		String[] results = {
				"elephant",
				"elephantine",
				"phantom",
				"sycophantic",
				"triumphant",
				"triumphantly"
		};
		assertArrayEquals(RiTa.search("phant"), results);
		assertArrayEquals(RiTa.search("/phant/"), results);

	}

	@Test
	public void testSearchWithPhones() {
		String[] results = {
				"elephant",
				"infant",
				"infantile",
				"infantry",
				"oftentimes"
		};

		Map<String, Object> hm = new HashMap<String, Object>();
		hm.put("type", "phones");
		hm.put("limit", 5);
		assertArrayEquals(RiTa.search("f-ah-n-t", hm), results);

		String[] result2 = {
				"elephant",
				"elephantine",
				"fantasia",
				"fantasize",
				"fantastic",
				"fantastically",
				"fantasy",
				"infant",
				"infantile",
				"infantry"
		};

		hm.clear();
		hm.put("type", "phones");
		hm.put("limit", 10);
		assertArrayEquals(RiTa.search("/f-a[eh]-n-t/", hm), result2);

	}

	@Test
	public void testSearchWithPos() {
		 Map<String, Object> hm = new HashMap<String, Object>();
		 hm.put("type", "stresses");
		 hm.put("limit", 5);
		 hm.put("pos", "n");

		 assertArrayEquals(RiTa.search("010", hm), new String[]{"abalone", "abandonment", "abatement", "abbreviation", "abdomen"});

		 hm.put("numSyllables", 3);
		 assertArrayEquals(RiTa.search("010", hm), new String[]{"abatement", "abdomen", "abduction", "abeyance", "abortion"});

		 hm.clear();
		 hm.put("type", "phones");
		 hm.put("limit", 3);
		 hm.put("pos", "n");
		 assertArrayEquals(RiTa.search("f-ah-n-t", hm), new String[]{"elephant", "infant", "infantry"});

		 hm.put("numSyllables", 2);
		 assertArrayEquals(RiTa.search("f-ah-n-t", hm), new String[]{"infant"});

		 hm.clear();
		 hm.put("type", "phones");
		 hm.put("limit", 5);
		 hm.put("pos", "v")
		 assertArrayEquals(RiTa.search("/f-a[eh]-n-t/", hm), new String[]{"fantasize"});

		 hm.clear();
		 hm.put("type", "stresses");
		 hm.put("limit", 5);
		 hm.put("pos", "nns")
		 assertArrayEquals(RiTa.search("010", hm), new String[]{"abalone", "abandonments", "abatements", "abbreviations", "abdomens"});

		 hm.put("numSyllables", 3);
		 assertArrayEquals(RiTa.search("010", hm), new String[]{"abatements", "abdomens", "abductions", "abeyances", "abortions"});

		 hm.clear();
		 hm.put("type", "phones");
		 hm.put("limit", 3);
		 hm.put("pos", "nns")
		 assertArrayEquals(RiTa.search("f-ah-n-t", hm), new String[]{"elephants", "infants", "infantries"});

		 hm.clear();
		 hm.put("type", "phones");
		 hm.put("limit", 5);
		 hm.put("pos", "vb")
		 assertArrayEquals(RiTa.search("/f-a[eh]-n-t/", hm), new String[]{"fantasize"});

	}

	@Test
	public void testSearchWithStress() {
		Map<String, Object> hm = new HashMap<String, Object>();
		hm.put("type", "stresses");
		hm.put("limit", 5);

		assertArrayEquals(RiTa.search("0/1/0/0/0/0", hm), new String[] {
				"accountability",
				"anticipatory",
				"appreciatively",
				"authoritarianism",
				"colonialism" });

		assertArrayEquals(RiTa.search("010000", hm), new String[] {
				"accountability",
				"anticipatory",
				"appreciatively",
				"authoritarianism",
				"colonialism" });

		hm.put("maxLength", 11);

		assertArrayEquals(RiTa.search("010000", hm), new String[] {
				"colonialism",
				"imperialism",
				"materialism" });

		hm.clear();
		hm.put("type", "stresses");
		hm.put("limit", 5);
		hm.put("minLength", 12);

		assertArrayEquals(RiTa.search("010000", hm), new String[] {
				"accountability",
				"anticipatory",
				"appreciatively",
				"authoritarianism",
				"conciliatory" });

	}

	@Test
	public void testRandomWordPosSyls() {
		// TODO:

	}

	@Test
	public void testToPhoneArray() {

		String[] result = RiTa._lexicon().toPhoneArray(RiTa._lexicon()._rawPhones("tornado", false));
		String[] ans = { "t", "ao", "r", "n", "ey", "d", "ow" };
		assertArrayEquals(result, ans);

	}

	@Test
	public void testAlliterationsNumSyllables() {
		// TODO:
	}

	@Test
	public void testAlliterationsPos() {
		Map<String, Object> hm = new HashMap<String, Object>();
		hm.put("minLength", 1);
		hm.put("numSyllables", 7);
		hm.put("pos", "n");

		String[] result = RiTa.alliterations("cat", hm);

		assertArrayEquals(result, new String[] { "electrocardiogram", "telecommunications" });

		for (int i = 0; i < result.length; i++) {
			assertTrue(RiTa.isAlliteration(result[i], "cat"));
		}

		hm.clear();
		hm.put("minLength", 14);
		hm.put("pos", "v");

		assertArrayEquals(RiTa.alliterations("dog", hm), new String[] { "disenfranchise" });

		hm.clear();
		hm.put("minLength", 13);
		hm.put("pos", "rb");

		assertArrayEquals(RiTa.alliterations("dog", hm), new String[] {
				"coincidentally",
				"conditionally",
				"confidentially",
				"contradictorily",
				"devastatingly",
				"expeditiously",
				"paradoxically",
				"predominantly",
				"traditionally",
				"unconditionally",
				"unpredictably" });

		hm.clear();
		hm.put("minLength", 14);
		hm.put("pos", "nns");

		assertArrayEquals(RiTa.alliterations("freedom", hm), new String[] {
				"featherbeddings",
				"fundamentalists",
				"malfunctionings",
				"pharmaceuticals",
				"photosyntheses",
				"reconfigurations",
				"sophistications" });

	}

	@Test
	public void testAlliterations() {

		String[] result;

		// TODO: make sure we have LTS cases in here

		result = RiTa.alliterations("");
		assertTrue(result.length < 1);

		result = RiTa.alliterations("#$%^&*");
		assertTrue(result.length < 1);

		result = RiTa.alliterations("umbrella");
		assertTrue(result.length < 1);

		result = RiTa.alliterations("cat");
		assertTrue(result.length > 2000);
		for (int i = 0; i < result.length; i++) {
			assertTrue(RiTa.isAlliteration(result[i], "cat"));
		}

		result = RiTa.alliterations("dog");
		assertTrue(result.length > 1000);
		for (int i = 0; i < result.length; i++) {
			assertTrue(RiTa.isAlliteration(result[i], "dog"));
		}

		Map<String, Object> hm = new HashMap<String, Object>();

		hm.put("matchMinLength", 15);

		result = RiTa.alliterations("dog", hm);
		assertTrue(result.length > 0 && result.length < 5); // , "got length=" + result.length
		for (int i = 0; i < result.length; i++) {
			assertTrue(RiTa.isAlliteration(result[i], "dog")); // , "FAIL1: " + result[i]
		}

		hm.clear();
		hm.put("matchMinLength", 16);

		result = RiTa.alliterations("cat", hm);
		assertTrue(result.length > 0 && result.length < 15);
		for (int i = 0; i < result.length; i++) {
			assertTrue(RiTa.isAlliteration(result[i], "cat"));// , "FAIL2: " + result[i]
		}

		result = RiTa.alliterations("khatt", hm);
		assertTrue(result.length > 0 && result.length < 15);
		for (int i = 0; i < result.length; i++) {
			assertTrue(RiTa.isAlliteration(result[i], "cat"));// , "FAIL2: " + result[i]
		}

	}

	public static boolean contains(String[] arr, String item) {
		for (String n : arr) {
			if (item == n) {
				return true;
			}
		}
		return false;
	}

	@Test
	public void testRhymes() {

		assertTrue(Arrays.asList(RiTa.rhymes("cat")).contains("hat"));
		assertTrue(Arrays.asList(RiTa.rhymes("yellow")).contains("mellow"));
		assertTrue(Arrays.asList(RiTa.rhymes("toy")).contains("boy"));
		assertTrue(Arrays.asList(RiTa.rhymes("sieve")).contains("give"));

		assertTrue(Arrays.asList(RiTa.rhymes("tense")).contains("sense"));
		assertTrue(Arrays.asList(RiTa.rhymes("crab")).contains("drab"));
		assertTrue(Arrays.asList(RiTa.rhymes("shore")).contains("more"));

		assertTrue(Arrays.asList(RiTa.rhymes("mouse")).contains("house"));

		assertTrue(Arrays.asList(RiTa.rhymes("weight")).contains("eight"));
//		System.out.println(Arrays.asList(RiTa.rhymes("eight")));
		assertTrue(Arrays.asList(RiTa.rhymes("eight")).contains("weight"));

		assertTrue(!Arrays.asList(RiTa.rhymes("apple")).contains("polo"));
		assertTrue(!Arrays.asList(RiTa.rhymes("this")).contains("these"));

		assertTrue(!Arrays.asList(RiTa.rhymes("hose")).contains("house"));
		assertTrue(!Arrays.asList(RiTa.rhymes("sieve")).contains("mellow"));
		assertTrue(!Arrays.asList(RiTa.rhymes("swag")).contains("grab"));

	}

	@Test
	public void testRhymesPos() {
		// TODO:
	}

	@Test
	public void testRhymesNumSyllables() {
		// TODO:
	}

	@Test
	public void testRhymesWordLength() {
		// TODO:
	}

	@Test
	public void testSpellsLike() {
		String[] result, answer;

		Map<String, Object> hm = new HashMap<String, Object>();
		hm.put("minLength", 6);
		hm.put("maxLength", 6);

		result = RiTa.spellsLike("banana", hm);
		assertArrayEquals(result, new String[] { "cabana" });

		hm.clear();

		result = RiTa.spellsLike("");
		assertArrayEquals(result, new String[] { });

		result = RiTa.spellsLike("banana", hm);
		assertArrayEquals(result, new String[] { "banal", "bonanza", "cabana", "manna" });

		hm.put("minLength", 6);
		hm.put("maxLength", 6);
		result = RiTa.spellsLike("banana", hm);
		assertArrayEquals(result, new String[] { "cabana" });

		hm.clear();
		hm.put("minDistance", 1);
		assertArrayEquals(result, new String[] { "banal", "bonanza", "cabana", "manna" });

		result = RiTa.spellsLike("tornado");
		assertArrayEquals(result, new String[] { "torpedo" });

		result = RiTa.spellsLike("ice");
		assertArrayEquals(result, new String[] { "ace", "dice", "iced", "icy", "ire", "nice", "rice", "vice" });

		hm.clear();
		hm.put("minAllowedDistance", 1);
		result = RiTa.spellsLike("ice", hm);
		assertArrayEquals(result, new String[] { "ace", "dice", "iced", "icy", "ire", "nice", "rice", "vice" });

		hm.clear();
		hm.put("minAllowedDistance", 2);
		hm.put("minLength", 3);
		hm.put("maxLength", 3);
		result = RiTa.spellsLike("ice", hm);
		assertTrue(result.length > 10);

		hm.clear();
		hm.put("minLength", 3);
		hm.put("maxLength", 3);
		hm.put("minAllowedDistance", 0);
		result = RiTa.spellsLike("ice", hm);
		assertArrayEquals(result, new String[] { "ace", "icy", "ire" });

		hm.clear();
		hm.put("minLength", 3);
		hm.put("maxLength", 3);
		result = RiTa.spellsLike("ice", hm);
		assertArrayEquals(result, new String[] { "ace", "icy", "ire" });

		hm.put("pos", "n");
		result = RiTa.spellsLike("ice", hm);
		assertArrayEquals(result, new String[] { "ace", "ire" });

		hm.clear();
		hm.put("minLength", 4);
		hm.put("maxLength", 4);
		hm.put("pos", "v");
		hm.put("limit", 5);
		result = RiTa.spellsLike("ice", hm);
		assertArrayEquals(result, new String[] { "ache", "bide", "bite", "cite", "dine" });

		hm.clear();
		hm.put("minLength", 4);
		hm.put("maxLength", 4);
		hm.put("pos", "nns");
		hm.put("limit", 5);
		result = RiTa.spellsLike("ice", hm);
		assertArrayEquals(result, new String[] { "aches", "acres", "aides", "apices", "axes" });

		result = RiTa.spellsLike("123", hm);
		assertTrue(result.length > 400);

	}

	@Test
	public void testSoundsLike() {
		// TODO:
	}

	@Test
	public void testSoundsLikeMatchSpelling() {
		// TODO:
	}

	// @Test
	// public void testSimilarBy() {
	//
	// String[] result, answer;
	//
	// Map<String, Object> hm = new HashMap<String, Object>();
	//
	// hm.put("preserveLength", true);
	//
	//
	// //similarBy(letter)
	// result = RiTa.similarBy("banana", hm);
	// System.out.println("result : ");
	// System.out.println(Arrays.toString(result));
	// assertArrayEquals(result, new String[]{"cabana"});
	// /*//TODO do we need one param option?
	// result = RiTa.similarBy("");
	// assertArrayEquals(result, new String[]{});
	// */
	// hm.clear();
	// hm.put("preserveLength", false);
	//
	// result = RiTa.similarBy("banana", hm);
	// assertArrayEquals(result, new String[]{"banal", "bonanza", "cabana",
	// "manna"});
	//
	// /*//TODO do we need one param option?
	// result = RiTa.similarBy("banana");
	// assertArrayEquals(result, new String[]{"banal", "bonanza", "cabana",
	// "manna"});
	// */
	//
	// hm.clear();
	// hm.put("minAllowedDistance", 1);
	// hm.put("preserveLength", true);
	// result = RiTa.similarBy("banana", hm);
	// assertArrayEquals(result, new String[]{"cabana"});
	//
	// hm.clear();
	// hm.put("minAllowedDistance", 1);
	// hm.put("preserveLength", false);
	// result = RiTa.similarBy("banana", hm);
	// assertArrayEquals(result, new String[]{"banal", "bonanza", "cabana",
	// "manna"});
	//
	// /*//TODO do we need one param option?
	// result = RiTa.similarBy("tornado");
	// assertArrayEquals(result, new String[]{"torpedo"});
	//
	// result = RiTa.similarBy("ice");
	// assertArrayEquals(result, new String[]{"ace", "dice", "iced", "icy", "ire",
	// "nice", "rice", "vice"});
	// */
	// hm.clear();
	// hm.put("minAllowedDistance", 1);
	// result = RiTa.similarBy("ice", hm);
	// assertArrayEquals(result, new String[]{"ace", "dice", "iced", "icy", "ire",
	// "nice", "rice", "vice"});
	//
	// hm.clear();
	// hm.put("minAllowedDistance", 2);
	// hm.put("preserveLength", true);
	// result = RiTa.similarBy("ice", hm);
	// assertTrue(result.length > 10);
	//
	//
	// hm.clear();
	// hm.put("minAllowedDistance", 0);
	// hm.put("preserveLength", true);
	// result = RiTa.similarBy("ice", hm); // defaults to 1
	// assertArrayEquals(result, new String[]{"ace", "icy", "ire"});
	//
	// hm.clear();
	// hm.put("minAllowedDistance", 1);
	// hm.put("preserveLength", true);
	// result = RiTa.similarBy("ice", hm);
	// assertArrayEquals(result, new String[]{"ace", "icy", "ire"});
	// /*//TODO do we need one param option?
	// result = RiTa.similarBy("worngword");
	// assertArrayEquals(result, new String[]{"foreword", "wormwood"});
	//
	// result = RiTa.similarBy("123");
	// assertTrue(result.length > 400);
	// */
	// //similarBy(sound)
	//
	// hm.clear();
	// hm.put("type", "sound");
	// assertArrayEquals(RiTa.similarBy("tornado", hm), new String[]{"torpedo"});
	//
	// hm.clear();
	// hm.put("type", "sound");
	// result = RiTa.similarBy("try", hm);
	// answer = new String[]{"cry", "dry", "fry", "pry", "rye", "tie", "tray",
	// "tree", "tribe", "tried", "tripe", "trite", "true", "wry"};
	// assertArrayEquals(result, answer);
	//
	// hm.clear();
	// hm.put("type", "sound");
	// hm.put("minAllowedDistance", 2);
	// result = RiTa.similarBy("try", hm);
	// assertTrue(result.length > answer.length); // more
	//
	// hm.clear();
	// hm.put("type", "sound");
	// result = RiTa.similarBy("happy", hm);
	// answer = new String[]{"happier", "hippie"};
	// assertArrayEquals(result, answer);
	//
	// hm.clear();
	// hm.put("type", "sound");
	// hm.put("minAllowedDistance", 2);
	// result = RiTa.similarBy("happy", hm);
	// assertTrue(result.length > answer.length); // more
	//
	// hm.clear();
	// hm.put("type", "sound");
	// result = RiTa.similarBy("cat", hm);
	// answer = new String[]{"at", "bat", "cab", "cache", "calf", "calve", "can",
	// "can\"t", "cap", "capped", "cash", "cashed", "cast", "caste", "catch",
	// "catty", "caught", "chat", "coat", "cot", "curt", "cut", "fat", "hat", "kit",
	// "kite", "mat", "matt", "matte", "pat", "rat", "sat", "tat", "that", "vat"};
	// assertArrayEquals(result, answer);
	//
	// hm.clear();
	// hm.put("type", "sound");
	// hm.put("minAllowedDistance", 2);
	// result = RiTa.similarBy("cat", hm);
	// assertTrue(result.length > answer.length);
	//
	// hm.clear();
	// hm.put("type", "sound");
	// result = RiTa.similarBy("worngword", hm);
	// assertArrayEquals(result, new String[]{"watchword", "wayward", "wormwood"});
	//
	//
	//
	// //similarBy(soundAndLetter)
	//
	// //result = RiTa.similarBy("", { type: "soundAndLetter" }
	// //assertArrayEquals(result, new String[]{});
	//
	// hm.clear();
	// hm.put("type", "soundAndLetter");
	// result = RiTa.similarBy("try", hm);
	// assertArrayEquals(result, new String[]{"cry", "dry", "fry", "pry", "tray",
	// "wry"});
	//
	// hm.clear();
	// hm.put("type", "soundAndLetter");
	// result = RiTa.similarBy("daddy", hm);
	// assertArrayEquals(result, new String[]{"dandy", "paddy"});
	//
	// hm.clear();
	// hm.put("type", "soundAndLetter");
	// result = RiTa.similarBy("banana", hm);
	// assertArrayEquals(result, new String[]{"bonanza"});
	//
	// hm.clear();
	// hm.put("type", "soundAndLetter");
	// result = RiTa.similarBy("worngword", hm);
	// assertArrayEquals(result, new String[]{"wormwood"});
	// }
	//

	@Test
	public void testIsRhyme() {

		assertTrue(!RiTa.isRhyme("apple", "polo"));
		assertTrue(!RiTa.isRhyme("this", "these"));

		assertTrue(RiTa.isRhyme("cat", "hat"));
		assertTrue(RiTa.isRhyme("yellow", "mellow"));
		assertTrue(RiTa.isRhyme("toy", "boy"));

		assertTrue(RiTa.isRhyme("solo", "tomorrow"));
		assertTrue(RiTa.isRhyme("tense", "sense"));
		assertTrue(RiTa.isRhyme("crab", "drab"));
		assertTrue(RiTa.isRhyme("shore", "more"));
		assertTrue(!RiTa.isRhyme("hose", "house"));
		assertTrue(!RiTa.isRhyme("sieve", "mellow"));

		assertTrue(RiTa.isRhyme("mouse", "house")); // why??
		// assertTrue(!RiTa.isRhyme("solo", "yoyo"));
		// assertTrue(!RiTa.isRhyme("yoyo", "jojo")); -> Known Issues

		assertTrue(RiTa.isRhyme("yo", "bro"));
		assertTrue(!RiTa.isRhyme("swag", "grab"));
		assertTrue(!RiTa.isRhyme("", ""));

		assertTrue(RiTa.isRhyme("weight", "eight"));
		assertTrue(RiTa.isRhyme("eight", "weight"));

		assertTrue(RiTa.isRhyme("sieve", "give"));

	}

	@Test
	public void testIsAlliteration() {

		assertTrue(RiTa.isAlliteration("knife", "gnat")); // gnat=lts
		assertTrue(RiTa.isAlliteration("knife", "naughty"));

		assertTrue(RiTa.isAlliteration("sally", "silly"));
		assertTrue(RiTa.isAlliteration("sea", "seven"));
		assertTrue(RiTa.isAlliteration("silly", "seven"));
		assertTrue(RiTa.isAlliteration("sea", "sally"));

		assertTrue(RiTa.isAlliteration("big", "bad"));
		assertTrue(RiTa.isAlliteration("bad", "big")); // swap position

		assertTrue(RiTa.isAlliteration("BIG", "bad")); // CAPITAL LETTERS
		assertTrue(RiTa.isAlliteration("big", "BAD")); // CAPITAL LETTERS
		assertTrue(RiTa.isAlliteration("BIG", "BAD")); // CAPITAL LETTERS

		// False
		assertTrue(!RiTa.isAlliteration("", ""));
		assertTrue(!RiTa.isAlliteration("wind", "withdraw"));
		assertTrue(!RiTa.isAlliteration("solo", "tomorrow"));
		assertTrue(!RiTa.isAlliteration("solo", "yoyo"));
		assertTrue(!RiTa.isAlliteration("yoyo", "jojo"));
		assertTrue(!RiTa.isAlliteration("cat", "access"));

		assertTrue(RiTa.isAlliteration("unsung", "sine"));
		assertTrue(RiTa.isAlliteration("job", "gene"));
		assertTrue(RiTa.isAlliteration("jeans", "gentle"));

		assertTrue(RiTa.isAlliteration("abet", "better"));
		assertTrue(RiTa.isAlliteration("never", "knight"));
		assertTrue(RiTa.isAlliteration("knight", "navel"));
		assertTrue(RiTa.isAlliteration("cat", "kitchen"));

		// not counting assonance
		assertTrue(!RiTa.isAlliteration("octopus", "oblong"));
		assertTrue(!RiTa.isAlliteration("omen", "open"));
		assertTrue(!RiTa.isAlliteration("amicable", "atmosphere"));

		assertTrue(RiTa.isAlliteration("this", "these"));
		assertTrue(RiTa.isAlliteration("psychology", "cholera"));
		assertTrue(RiTa.isAlliteration("consult", "sultan"));
		assertTrue(RiTa.isAlliteration("monsoon", "super"));

	}

}
